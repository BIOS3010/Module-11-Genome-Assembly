# Exercise 3: Genome assembly quality assessment

Now we have put together the same reads using two different programs,
and obtained different assemblies. Which one is better?

To help us answer this, we will use two programs.

* BUSCO checks whether a set of conserved genes, that we can assume should be present in the species, are in fact in the assembly
* Quast allows us to compare the assemblies to a reference genome, which is a the best available assembly for this species

If you do not have a reference genome, a tool like BUSCO is very useful.
If you do have a reference genome, you can check your assembly against it using Quast.

**Today** we will start the analysis with both programs. These will run for a while, so we will interpret the results in the next lab.

## Assembly completeness - BUSCO

We like to use BUSCO to assess the completeness of an assembly. BUSCO (https://busco.ezlab.org/) uses a set of conserved genes that should be present in the species we are interested in. For instance, if you run it on a mammalian species, it tries to find 4104 genes. A high quality genome assembly should have the vast majority of these present and with exons in the correct order and orientation with regards to each other. In vertebrates, genes can span several 100 kbp, so if most genes are found complete, it is likely that the genome assembly is of high quality.

### Running BUSCO

First, let's do the assembly QC in a new folder, for example `~/assembly_qc`. Create this folder and `cd` into it.

Second, as the BUSCO analysis will take some time (an hour or so), we run it again inside a *screen*. It is advised to start a new screen for this.

*NOTE* feel free to terminate any other screens you still may have by re-entering them and writing `exit`.

To get started with BUSCO, we need to run the following commands:

```
module load BUSCO/5.0.0-foss-2020a
```

To have a look at the available BUSCO gene sets for different species use:

`busco --list-datasets`

We will all run BUSCO using the insect dataset, **insecta_odb10**.

To run BUSCO on the canu assembly use:

```
busco \
-c 2 \
-i /home/username/canu_assembly/canu_assembly.contigs.fasta \
-l insecta_odb10 \
-m genome \
-o canu_busco 1> canu_busco.out 2> canu_busco.err
```

For flye, use

```
busco \
-c 2 \
-i /home/username/flye_assembly/assembly.fasta \
-l insecta_odb10 \
-m genome \
-o flye_busco 1> flye_busco.out 2> flye_busco.err
```

As always, change `username` with your username and make sure the path to the assembly file is correct.

**NOTE** *If your assembly did not complete*, use one of the finished assemblies that we made available.
Do not copy the assembly, but point BUSCO to the assembly fasta file:
* canu: `/storage/BIOS3010/Genome_assembly/canu_assembly/canu_assembly.contigs.fasta`
* flye: `/storage/BIOS3010/Genome_assembly/flye_assembly/assembly.fasta`

In the command for running BUSCO:
* we use the backslash `\` so we can write the command over multiple lines, making it easier to read
* `-c 2` means use 2 compute threads (CPUs)
* `-i ` is the assembly file to use
* `-l` is the name if the gene set
* `-m genome` indicates we are testing a full genome (not only a set of gene or protein sequences)
* `-o` indicates the name of the folder BUSCO will write its output in
* `1> canu_busco.out 2> canu_busco.err` asks unix to save the messages from BUSCO in different files.

Exit the screen with `Ctrl + A + D` as before.

Check to see if BUSCO is running using `top` and checking the `.out` file.

BUSCO is finished when the `.out` file has a table of the results at the end, followed by three lines of which the first reads `INFO:   BUSCO analysis done. Total running time: XXX seconds`.

Once BUSCO is running, proceed to start Quast as described below.

## Assembly contiguity and correctness - QUAST

After doing a genome assembly, one of the questions is often about how correct and contiguous the assembly is. The term *contiguous* refers to how well the different sequences have been put together. An assembly is more contiguous the fewer contigs it has.

It is not straight-forward to evaluate correctness for many projects. However, for *Bombus campestris* we have a reference to compare to downloaded from https://www.ebi.ac.uk/ena/browser/view/GCA_905333015, located in the shared folder here:

`less /storage/BIOS3010/Genome_assembly/CAJOSK02.fasta`

This genome was generated using the following pipeline (from https://www.ebi.ac.uk/ena/browser/view/GCA_905333015):

> The assembly iyBomCamp1.2 is based on 83x PacBio data, 10X Genomics Chromium data, and Arima Hi-C data generated by the Darwin Tree of Life Project (https://www.darwintreeoflife.org/). The assembly process included the following sequence of steps: initial PacBio assembly generation with Hifiasm, retained haplotig separation with purge_dups, short-read polishing using FreeBayes-called variants from 10X Genomics Chromium reads aligned with LongRanger, and Hi-C based scaffolding with SALSA2. The mitochondrial genome was assembled using MitoHifi. Finally, the assembly was analysed and manually improved using gEVAL. Chromosome-scale scaffolds confirmed by the Hi-C data have been named in order of size.

This reference is the best available genome assembly for this species. We will assume it has no errors - but we can never be sure. It likely will have some errors, but probably not many.

We can use Quast (http://quast.sourceforge.net) to find many different metrics of our genome assembly such as N50, number of misassemblies relative to the reference, and number of genes. See more of the results given here: http://quast.sourceforge.net/docs/manual.html#sec3.1.

To get started with Quast, we need to run the following commands:

```
module load QUAST/5.0.2-foss-2020a-Python-3.8.2
```

Work in your `assembly_qc` folder and use `screen` as before -
the aalysis will take an hour or so.

To run Quast on the canu assembly use:

```
quast \
/home/username/canu_assembly/canu_assembly.contigs.fasta \
-r /storage/BIOS3010/Genome_assembly/CAJOSK02.fasta  \
-o canu_quast \
-t 2 \
1> canu_quast.out 2> canu_quast.err
```

For flye, use

```
quast \
/home/username/flye_assembly/assembly.fasta \
-r /storage/BIOS3010/Genome_assembly/CAJOSK02.fasta \
-o flye_quast \
-t 2 \
1> flye_quast.out 2> flye_quast.err
```

As always, change `username` with your username and make sure the path to the assembly file is correct.

Here:
* we use the path to the assembly fasta file as first argument
* `-r` indicates the path to the reference genome that Quast uses for comparison
* `-o` indicates the name of the folder Quast will write its output in
* `-t 2` means use 2 compute threads (CPUs)

If you want to run it on your own assembly, or the one we prvided in `/storage/BIOS3010/Genome_assembly`, make sure the paths are correct.

Exit the screen with `Ctrl + A + D` as before.

Check to see if Quast is running using `top` and checking the `.out` file.

Quast is finished when the `.out` file ends with `Thank you for using QUAST!`

### Next steps

In the next lab, we will interpret the results.

## Other things to try

### Run BUSCO with a different species-specific gene set

Take a look at the available BUSCO gene sets for different species again with `busco --list-datasets`.
You could try a different one in addition to `insecta_odb10`, for instance for arthropods or eukaryotes.

### Canu: QC assembly without bubble sequences

If you check the file `canu_assembly.report` it will have a number of contigs listed at the end. However, if you count how many contigs there are in `canu_assembly.contigs.fasta` you will see it is the higher. The fasta file has all contigs, *as well as* so-called Bubble sequences.
Bubble sequences are the result of heterozygosit, sequence differences between the two chromosomes of the sampled individual. They do not make up a large fraction of the assembly, but still contribute a significant fraction.

To find out which seqeunces in `canu_assembly.contigs.fasta` are bubbles, look inside the file: the sequence header (the line starting with `>`) has either `suggestBubble=yes` or `suggestBubble=no`.

You can read more about bubbles in the publication for canu: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5411767/ (search for 'assembly bubble').

One interesting question would be what the assembly QC results are for the contigs `excluding` the bubbles. For example, do we still have the same results for BUSCO, or is one of the conserved genes in one of the bubble sequences? Since bubbles are similar to another region in the same assembly, will Quast report a lower `Duplication ratio`?

Use your Python and Biopython knowledge to write a Python program that filters the contigs in `canu_assembly.contigs.fasta` and creates a file with contigs that are not indicated as bubbles. Run BUSCO and Quast on this file and compare the results with the analysis of `canu_assembly.contigs.fasta`
